<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>emilib: emilib</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">emilib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">emilib </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a loose collection of C++14 libraries I tend to reuse between different (mostly game-related) projects.</p>
<p>They are meant mostly for me (Emil Ernerfeldt), but if you find them useful, have at it.</p>
<p>Their only dependencies are either system dependencies (pthread etc) and <a href="https://github.com/emilk/loguru">Loguru</a>. gl_lib also depends on OpenGL and GLEW. The libraries does not depend on each other (with an exception for ShaderMngr).</p>
<p>They all work on OSX and iOS and probably Linux. Some may work elsewhere.</p>
<h1>License</h1>
<p>This software is in the public domain. Where that dedication is not recognized, you are granted a perpetual, irrevocable license to copy and modify this file as you see fit.</p>
<h1>Documentation</h1>
<p>Documentation can be found at <a href="https://emilk.github.io/emilib/html/index.html">https://emilk.github.io/emilib/html/index.html</a>.</p>
<h1>Usage</h1>
<p>Most libraries in emilib are stand-alone, so you can, for instance, use the coroutine library without having to compile anything but that.</p>
<p>Some are header-only, but most come with a <code>.cpp</code> file too.</p>
<p>To use a single library, just <code>#include</code> the header, and if there is a <code>.cpp</code> (or <code>.mm</code> in case of iOS/OSX) either compile and link that, or just include that too, e.g.: </p><pre class="fragment">#include &lt;emilib/coroutine.hpp&gt;
#include &lt;emilib/coroutine.cpp&gt; // Do this only in one of your .cpp files
</pre><p>You can also make use of <code>unity_build.cpp</code> to compile all of emilib all at once. To use the iOS/OSX specific libraries, use <code>unity_build.mm</code> instead.</p>
<p>You also need to compile Loguru. Luckily, <code>loguru.hpp</code> is included in this repo, and to compile it you just need to add the following to one of your .cpp files: </p><pre class="fragment">#define LOGURU_IMPLEMENTATION
#include &lt;loguru.hpp&gt;
</pre><p>Make sure you compile with -std=c++11 -lpthread -ldl</p>
<h4>Documentation</h4>
<p>This file (README.md) contains an overview of each library. Read the header for each library to learn more.</p>
<h4>Examples</h4>
<p>There is a very limited set of examples in the <code>examples/</code> folder.</p>
<h4>Tests</h4>
<p>There is a very limited set of tests in the <code>tests/</code> folder.</p>
<h1>Stand-alone libraries</h1>
<h4><a class="el" href="coroutine_8hpp_source.html">coroutine.hpp</a>/.cpp</h4>
<p>This is a "fake coroutine" class which implements a cooperative thread and methods for passing execution between the outer and inner thread.</p>
<p>This is really nice for handling things that you would normally use a state machine for. Perfect for games where you might want to have a scripted event, a dialogue or something else running in its own thread, but not at the same time as the main game logic thread.</p>
<h4><a class="el" href="dir__watcher_8hpp_source.html">dir_watcher.hpp</a>/.cpp</h4>
<p>This library allows you to watch for changes in a directory, e.g. new files, deleted files or changes in existing files. This is great for doing automatic hot-reloading of things like textures, shaders, etc.</p>
<p>POSIX systems only.</p>
<h4><a class="el" href="dual_8hpp_source.html">dual.hpp</a></h4>
<p>Library for <a href="https://en.wikipedia.org/wiki/Dual_number">dual numbers</a>. Can be used for numerical stable differentiation. Works inside of Eigen.</p>
<h4>filesystem.hpp/.cpp</h4>
<p>Contains functions for easily reading/writing files, getting file size and modified time, listing all files in a directory, etc.</p>
<p>It also contains functions for working with file paths.</p>
<h4><a class="el" href="hash__cache_8hpp_source.html">hash_cache.hpp</a></h4>
<p>HashCache wraps a value and memoizes the hash of that value. Can speed up hash sets and maps by a lot.</p>
<h4><a class="el" href="hash__map_8hpp_source.html">hash_map.hpp</a> / <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a></h4>
<p>Cache-friendly hash map/set with open addressing, linear probing and power-of-two capacity. Acts mostly like <code>std::unordered_map/std::unordered_set</code> except for:</p>
<ul>
<li>Much better performance</li>
<li>Key/values may move when rehashing</li>
</ul>
<h4><a class="el" href="irange_8hpp_source.html">irange.hpp</a></h4>
<p>Simple integer range, allowing you to replace <code>for (size_t i = 0; i &lt; limit; ++i)</code> with <code>for (auto i : irange(limit))</code>. It also provides a <code>Range</code> class which represent an integer range in a half-closed interval [begin, end) as well as the following functions:</p>
<div class="fragment"><div class="line">for (const auto ix : irange(end))                        { CHECK_F(0     &lt;= ix &amp;&amp; ix &lt; end);           }</div><div class="line">for (const auto ix : irange(begin, end))                 { CHECK_F(begin &lt;= ix &amp;&amp; ix &lt; end);           }</div><div class="line">for (const auto ix : indices(some_vector))               { CHECK_F(0 &lt;= ix &amp;&amp; ix &lt; some_vector.size(); }</div><div class="line">for (const char ch : emilib::cstr_range(&quot;hello world!&quot;)) { ...                                         }</div><div class="line">for (auto&amp; value : it_range(begin, end))                 { std::cout &lt;&lt; value;                         }</div></div><!-- fragment --><h4><a class="el" href="list__map_8hpp_source.html">list_map.hpp</a> / <a class="el" href="list__set_8hpp_source.html">list_set.hpp</a></h4>
<p>Simple O(N) map/set with small overhead and great performance for small N.</p>
<h4><a class="el" href="magica__voxel_8hpp_source.html">magica_voxel.hpp</a>/.cpp</h4>
<p>Loader for <a href="https://voxel.codeplex.com/">MagicaVoxel</a> models.</p>
<h4><a class="el" href="marching__squares_8hpp_source.html">marching_squares.hpp</a>/.cpp</h4>
<p>Short, simple marching squares implementation.</p>
<h4><a class="el" href="mem__map_8hpp_source.html">mem_map.hpp</a>/.cpp</h4>
<p>Simple wrapper around memory mapping with RAII.</p>
<h4><a class="el" href="movement__tracker_8hpp_source.html">movement_tracker.hpp</a>/.cpp</h4>
<p>Track movement of some data, e.g. to estimate velocity from recent movement. For instance, you can use this to track a finger flicking something on a touch-screen to calculate the final velocity when the finger is released.</p>
<h4><a class="el" href="read__write__mutex_8hpp_source.html">read_write_mutex.hpp</a></h4>
<p>Fast mutex for multiple-readers, single-writer scenarios written in pure C++11.</p>
<h4><a class="el" href="scope__exit_8hpp_source.html">scope_exit.hpp</a></h4>
<p>Adds the macro <code>SCOPE_EXIT</code> for running some code at the end of the scope (or when a function returns, etc). Example:</p>
<div class="fragment"><div class="line">void foo()</div><div class="line">{</div><div class="line">    File* file = fopen(...);</div><div class="line">    SCOPE_EXIT{ fclose(file); };</div><div class="line">    if (bar) { return; }</div><div class="line">    if (baz) { exit(); }</div><div class="line">    might_throw_an_exception(file);</div><div class="line">}</div></div><!-- fragment --><h4><a class="el" href="string__interning_8hpp_source.html">string_interning.hpp</a>/.cpp</h4>
<p>Stupid simple thread-safe string interning.</p>
<h4><a class="el" href="strprintf_8hpp_source.html">strprintf.hpp</a>/.cpp</h4>
<p>Minimalistic string formating library. Provides two functions: <code>strprintf</code> and <code>vstrprintf</code> that act like <code>printf</code> and <code>vprintf</code> respectively, but return the formated text as a <code>std::string</code> instead of printing it.</p>
<h4><a class="el" href="tga_8hpp_source.html">tga.hpp</a>/.cpp</h4>
<p>Dump a tga image to disk.</p>
<h4><a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>/.cpp</h4>
<p>A simple thread pool.</p>
<h4><a class="el" href="timer_8hpp_source.html">timer.hpp</a>/.cpp</h4>
<p>Monotonic wall time chronometer.</p>
<h4><a class="el" href="tuple__util_8hpp_source.html">tuple_util.hpp</a></h4>
<p>Adds <code>for_each_tuple</code> for iterating over a <code>std::tuple</code> and also overloads <code>std::hash</code> for <code>std::tuple</code>.</p>
<h4><a class="el" href="utf8_8hpp_source.html">utf8.hpp</a>/.cpp</h4>
<p>Really basic utf8 operations.</p>
<h4><a class="el" href="wav_8hpp_source.html">wav.hpp</a>/.cpp</h4>
<p>Parse WAVE (.wav) sound files.</p>
<h4><a class="el" href="word__wrap_8hpp_source.html">word_wrap.hpp</a>/.cpp</h4>
<p>Wrap lines of text to fit within a given width.</p>
<h1>iOS / OSX specific libraries:</h1>
<h4><a class="el" href="music_8hpp_source.html">music.hpp</a>/.mm</h4>
<p>Stream mp3 music on OSX and iOS.</p>
<h4><a class="el" href="os_8hpp_source.html">os.hpp</a>/.mm</h4>
<p>Device information like screen size and orientation.</p>
<h4><a class="el" href="pvr_8hpp_source.html">pvr.hpp</a>/.mm</h4>
<p>Loading of compressed .pvr textures. Depends on gl_lib.</p>
<h4><a class="el" href="text__paint_8hpp_source.html">text_paint.hpp</a>/.mm</h4>
<p>Pretty multi-line Unicode text rendering for OSX and iOS. It lets you select font, size, alignment, wrapping size and allows you to colorize and italicize sub-ranges of the text.</p>
<p>It draws the text to memory, so it is up to you to display it (e.g. upload it to a texture).</p>
<h1>Libraries with third-party dependencies</h1>
<h4>al_lib</h4>
<p>Code for loading, playing and positioning sounds using OpenAL.</p>
<p>Depends on OpenAL and other parts of emilib.</p>
<p>Include <code><a class="el" href="al__lib_8hpp_source.html">al_lib.hpp</a></code> and link with <code>al_lib.cpp</code>. You can also make use of <code><a class="el" href="al__lib__fwd_8hpp_source.html">al_lib_fwd.hpp</a></code> to bring in forward declarations for most things in al_lib.</p>
<h4>gl_lib</h4>
<p>Code for doing simple things in OpenGL and/or OpenGL ES (GLES). It has classes and methods for dealing with:</p>
<ul>
<li>2D Textures</li>
<li>Vertex and fragment shaders<ul>
<li>You can use the same shader code for GLES and non-GLES targets</li>
</ul>
</li>
<li>Vertex buffers (VBO/VAO)</li>
<li>Viewports</li>
<li>Off-screen buffers (FBO)</li>
</ul>
<p>Depends on OpenGL and GLEW.</p>
<p>Include <code><a class="el" href="gl__lib_8hpp_source.html">gl_lib.hpp</a></code> and link with <code>gl_lib.cpp</code>. You can also make use of <code><a class="el" href="gl__lib__fwd_8hpp_source.html">gl_lib_fwd.hpp</a></code> to bring in forward declarations for most things in gl_lib. To do OpenGL calls you can include <code><a class="el" href="gl__lib__opengl_8hpp_source.html">gl_lib_opengl.hpp</a></code> (which just includes the correct OpenGL and/or glew headers for you system).</p>
<h4><a class="el" href="gl__lib__sdl_8hpp_source.html">gl_lib_sdl.hpp</a>/.cpp</h4>
<p>Helper functions for creating an SDL2 OpenGL window.</p>
<h4><a class="el" href="imgui__gl__lib_8hpp_source.html">imgui_gl_lib.hpp</a>/.cpp</h4>
<p>Provides bindings between my <code>gl_lib</code> and the wonderful <a href="https://github.com/ocornut/imgui">Dear Imgui</a> GUI library. Can be used alone or together with <code><a class="el" href="imgui__sdl_8hpp_source.html">emilib/imgui_sdl.hpp</a>/.cpp</code>.</p>
<h4><a class="el" href="imgui__helpers_8hpp_source.html">imgui_helpers.hpp</a>/.cpp</h4>
<p>Helpers for working with the wonderful <a href="https://github.com/ocornut/imgui">Dear Imgui</a> GUI library.</p>
<h4><a class="el" href="imgui__sdl_8hpp_source.html">imgui_sdl.hpp</a>/.cpp</h4>
<p>Bindings between <a href="https://www.libsdl.org/">SDL2</a> and the wonderful <a href="https://github.com/ocornut/imgui">Dear Imgui</a> GUI library. Can be used alone or together with <code><a class="el" href="imgui__gl__lib_8hpp_source.html">emilib/imgui_gl_lib.hpp</a>/.cpp</code>..</p>
<h4><a class="el" href="shader__mngr_8hpp_source.html">shader_mngr.hpp</a>/.cpp</h4>
<p>This is NOT a stand-alone library, but depends on other parts of emilib as well as loguru and configuru. ShaderMngr's job is to encapsulate loading, memoization and reloading of shader files. In particular, ShaderMngr can detect changes in .shader files and automatically reload (hot-reloading) them.</p>
<h4><a class="el" href="texture__mngr_8hpp_source.html">texture_mngr.hpp</a>/.cpp</h4>
<p>This is NOT a stand-alone library, but depends on other parts of emilib as well as loguru. TextureMngr's job is to encapsulate loading, memoization and reloading of texture files. In particular, TextureMngr can detect changes in image files and automatically reload (hot-reloading) them.</p>
<h1>Libraries not part of emilib, but incldued for convenicence:</h1>
<h4>configuru.hpp</h4>
<p>This is not part of emilib, but a copy of <a href="https://github.com/emilk/configuru">https://github.com/emilk/configuru</a> here only for convenience.</p>
<h4>loguru.hpp</h4>
<p>This is not part of emilib, but a copy of <a href="https://github.com/emilk/loguru">https://github.com/emilk/loguru</a> here for convenience, and as a dependency for most other libraries. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
